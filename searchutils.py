import json
import datetime
import requests

class Search:
    def __init__(self, conn):
        self.__conn = conn

    def __serialize_datetime(obj):
        if isinstance(obj, datetime.datetime):
            return obj.isoformat()
        raise TypeError("Type not serializable")

    def get_full_graph(self):
        qry = "MATCH (n)-[r]->(m) "
        #qry += "RETURN collect({id: toString(id(n)), attributes: properties(n) }) AS nodes, "
        qry += "RETURN collect(distinct {id: toString(id(n)), group: labels(n)[0], attributes: properties(n)}) AS nodes, "
        #qry += "collect({ source: id(n), target: id(m), attributes: properties(r) }) AS links " 
        qry += "collect({ source: toString(id(n)), target: toString(id(m)), value: 1 }) AS links" 
        result = self.__conn.query(qry)
        #print(result)
        if result != None:
            nodes = result[0]['nodes']
            links = result[0]['links']
            # Some edges generated by Neo4J went nowhere - they connected to 
            # node IDs that did not exist in the [nodes] list.
            # The code below only uses edges where both source and target
            # exist in the [nodes] list
            for item in result[0]['links']:
                ids = [ sub['id'] for sub in nodes ]
                if item['source'] not in ids or item['target'] not in ids:
                    links.remove(item)
            d = {"nodes":nodes, "links":links}
            
        else:
            d = {"nodes": [], "links": []} #None
        return json.dumps(d)

    def search_plants(self, searchterms):
        #qry = "MATCH (f:Family)<-[r1:BELONGS_TO]-(g:Genus)<-[r2:BELONGS_TO]-(p:Plant) "
        #qry += "WHERE f.family_name = $searchterms return f, r1, g, r2, p;"

        #qry = "MATCH (f:Family)<-[r1:BELONGS_TO]-(g:Genus)<-[r2:BELONGS_TO]-(a:Animal) "
        #qry += "WHERE toLower(a.common_name) CONTAINS $searchterms return f, r1, g, r2, a;"

        qry = "MATCH (k:Kingdom)<-[r1:BELONGS_TO]-(p:Phylum)<-[r2:BELONGS_TO]-(c:Class)<-[r3:BELONGS_TO]-(o:Order)<-[r4:BELONGS_TO]-(f:Family)<-[r5:BELONGS_TO]-(g:Genus)<-[r6:BELONGS_TO]-(a:Animal) "
        #qry += "WHERE toLower(a.common_name) CONTAINS $searchterms "
        qry += "WHERE ANY(x IN $searchterms WHERE toLower(a.common_name) CONTAINS x) "
        qry += "RETURN k, r1, p, r2, c, r3, o, r4, f, r5, g, r6, a; "
  
        #print(qry)
        params = {
            "searchterms" : ['peccary', 'collared']
        }
        result = self.__conn.query(qry, parameters=params)
        data = {
            "nodes" : [],
            "links" : []
        }
        for record in result:
            for k, v in record.data().items():
                if k[0] != 'r':
                    v['group'] = ':'.join(list(record[k].labels))
                    data['nodes'].append(v)
                else:
                    # {"source": "First Woman", "target": "Tayag Woman", "value": 4},
                    link = {
                        "source" : v[0]['id'], "target" : v[2]['id'], "value" : 1
                    }
                    data['links'].append(link)
        return json.dumps(data)
    
    def pairwise_search(self, search_target, keywords):
        data = {
            "nodes" : [],
            "edges" : []
        }
        if search_target != "" and keywords != "" and search_target != None and keywords != None:
            if search_target == "1": # Narratives - Animals
                #qry = "MATCH (n:Narrative) WHERE toLower(n.title) CONTAINS $keywords OR toLower(n.text) CONTAINS $keywords "
                #qry += "OPTIONAL MATCH (a:Animal)-[r:APPEARS_IN]->(n) RETURN n, r, a;"
                qry = "MATCH (n:Narrative)<-[r:APPEARS_IN]-(a:Animal) WHERE toLower(n.title) CONTAINS $keywords RETURN n, r, a;"
            elif search_target == "2" : # Animals - Narratives
                qry = "MATCH (a:Animal)-[r:APPEARS_IN]-(n:Narrative) WHERE toLower(a.common_name) CONTAINS $keywords OR toLower(a.scientific_name) CONTAINS $keywords RETURN n, r, a;"
            elif search_target == "3" : # Narratives - Plants
                qry = "MATCH (n:Narrative)<-[r:APPEARS_IN]-(p:Plant) WHERE toLower(n.title) CONTAINS $keywords RETURN n, r, p;"
            elif search_target == "4" : # Plants - Narratives 
                qry = "MATCH (p:Plant)-[r:APPEARS_IN]->(n:Narrative) WHERE toLower(p.common_name) CONTAINS $keywords OR toLower(p.scientific_name) CONTAINS $keywords RETURN n, r, p;"
            elif search_target == "5" : # Narratives - Objects
                qry = "MATCH (n:Narrative)<-[r]-(o:Object) WHERE toLower(n.title) CONTAINS $keywords RETURN n, r, o;"
            elif search_target == "6" : # Objects - Narratives 
                qry = "MATCH (o:Object)-[r]->(n:Narrative) WHERE toLower(o.object_name) CONTAINS $keywords RETURN n, r, o;"
            print(qry)
            params = {
                "keywords" : keywords
            }
            #print(params)
            #print(qry)
            result = self.__conn.query(qry, parameters=params)
            
            for record in result:
                for k, v in record.data().items():
                    if v != None:
                        #print(v)
                        if k[0] != 'r':
                            v['group'] = ':'.join(list(record[k].labels))
                            v['name'] = v['id']
                            if "animal" in v['group'].lower() or "plant" in v['group'].lower():
                                v['display_name'] = v['common_name'] # + "\n" + v['scientific_name']
                            elif "narrative" in v['group'].lower():
                                v['display_name'] = v['title']
                            elif "object" in v['group'].lower():
                                v['display_name'] = v['object_name']
                            
                            data['nodes'].append(v)
                        else:
                            # {"source": "First Woman", "target": "Tayag Woman", "value": 4},
                            print(v[0])

                            link = {
                                "source" : v[0]['id'], "target" : v[2]['id'], "value" : 1
                            }
                            data['edges'].append(link)
            data['nodes'] = [dict(t) for t in {tuple(d.items()) for d in data['nodes']}]

        
        return json.dumps(data, default="str")
    
    def event_search(self, searchterms):
        qry = "MATCH (e:Event) "
        qry += "WHERE toLower(e.genus) CONTAINS toLower($searchterms) "
        qry += "OR toLower(e.family) CONTAINS toLower($searchterms) "
        qry += "OR toLower(e.species) CONTAINS toLower($searchterms) "
        #qry += "OPTIONAL MATCH (e)-[r]-(n) "
        #qry += "RETURN e, r, n;"
        qry += "RETURN e;"

        params = {
            "searchterms" : searchterms
        }
        #print(params)

        result = self.__conn.query(qry, parameters=params)
        events = []
        if result != None:
            for record in result:
                events.append(record.data()['e'])

        return json.dumps(events)
    
    def view_event(self, event_id):
        qry = "MATCH (e:Event) WHERE e.id = $event_id RETURN e;"

        params = {
            "event_id" : event_id
        }
        #print(params)

        result = self.__conn.query(qry, parameters=params)
        events = []
        if result != None:
            for record in result:
                events.append(record.data()['e'])

        return json.dumps(events)
    
    def search_entities(self, searchtarget, searchscope, searchterms):
        if searchtarget == "animals" or searchtarget == "plants":
            qry = "MATCH " 
            if searchtarget == "animals":
                qry +="(a:Animal) "
            elif searchtarget == "plants":
                qry +="(a:Plant) "
            else:
                qry +="(a:Animal) "

            if searchscope == "name":
                qry += "WHERE ANY(x IN $searchterms WHERE (toLower(a.common_name) CONTAINS x or toLower(a.scientific_name) CONTAINS x)) "
            elif searchscope == "family":
                qry += "WHERE ANY(x IN $searchterms WHERE toLower(f.family_name) CONTAINS x) "
            elif searchscope == "genus":
                qry += "WHERE ANY(x IN $searchterms WHERE toLower(g.genus_name) CONTAINS x) "
            qry += "OPTIONAL MATCH (k:Kingdom)<-[r1:BELONGS_TO]-(p:Phylum)<-[r2:BELONGS_TO]-(c:Class)<-[r3:BELONGS_TO]-(o:Order)<-[r4:BELONGS_TO]-(f:Family)<-[r5:BELONGS_TO]-(g:Genus)<-[r6:BELONGS_TO]-(a) "
            qry += "OPTIONAL MATCH (a)-[r7:APPEARS_IN]->(n:Narrative) "
            qry += "OPTIONAL MATCH (n)-[r8:TAKES_PLACE_IN]->(cntr:Country) "
            qry += "OPTIONAL MATCH (n)-[r9:PART_OF]->(coll:Collection) "
            qry += "RETURN k, r1, p, r2, c, r3, o, r4, f, r5, g, r6, a, r7, n, r8, coll, r9, cntr; "

        elif searchtarget == "narratives":
            qry = "MATCH (n:Narrative) "
            qry += "WHERE (ANY(x IN $searchterms WHERE toLower(n.title) CONTAINS x) "
            qry += "OR ANY(x IN $searchterms WHERE toLower(n.text) CONTAINS x)) "
            qry += "OPTIONAL MATCH (a)<-[r1]-(n) WHERE NOT a:File AND NOT a:Media  "
            qry += "OPTIONAL MATCH (n)<-[r2]-(b)  WHERE NOT b:File AND NOT b:Media  "
            #qry += "OPTIONAL MATCH (n)-[r3:TAKES_PLACE_IN]->(cntr:Country) "
            #qry += "OPTIONAL MATCH (n)-[r4:PART_OF]->(coll:Collection) "
            qry += "RETURN a, n, b, r1, r2"
        elif searchtarget == "objects":
            qry = "MATCH (o:Object) "
            qry += "WHERE ANY(x IN $searchterms WHERE toLower(o.object_name) CONTAINS x) "
            qry += " OPTIONAL MATCH (x)-[r1]-(o)-[r2]-(y) RETURN o, x, y, r1, r2;"
        elif searchtarget == "events":
            qry = "MATCH (e:Event) "
            qry += "OPTIONAL MATCH (a)<-[r1:OBSERVED]-(e)-[r2:OBSERVED]->(b) "
            qry += "RETURN a, r1, b, r2, e LIMIT 20;"
        elif searchtarget == "id":
            qry = "MATCH (a) WHERE a.id = $searchterms OPTIONAL MATCH (x)-[r1]-(a)-[r2]-(y) RETURN a, x, y, r1, r2;"
  
        
        #return json.dumps(search_list)
        searchterms = searchterms.lower()
        if searchtarget == "id":
            params = {
                "searchterms" : searchterms
            }
        else:
            temp = searchterms.split(' ')
            search_list = [searchterms, temp[-1]]
            params = {
                "searchterms" : search_list
            }
        #return qry
        result = self.__conn.query(qry, parameters=params)
        data = {
            "nodes" : [],
            "links" : []
        }
        for record in result:
            for k, v in record.data().items():
                if v != None:
                    if k[0] != 'r':
                        v['group'] = ':'.join(list(record[k].labels))
                        if k[0] == 'e': #event
                            temp = {
                                "id" : v['id'],
                                "group": "Event"
                            }
                            data['nodes'].append(temp)
                        else:
                            data['nodes'].append(v)
                    else:
                        # {"source": "First Woman", "target": "Tayag Woman", "value": 4},
                        link = {
                            "source" : v[0]['id'], "target" : v[2]['id'], "value" : 1
                        }
                        data['links'].append(link)
        data['nodes'] = [dict(t) for t in {tuple(d.items()) for d in data['nodes']}]
        #return json.dumps(data['links'])

        #temp = [sub['source'] for sub in data["links"]]
        #temp += [sub['target'] for sub in data["links"]]
        #temp = list(set(temp))
        #return json.dumps(temp)
        
        return json.dumps(data, default = str)
    
    def browse_entities(self, searchtarget, startletter="", entity_id=""):
        if searchtarget == "animals":
            qry = "MATCH (n:Animal) "
            if entity_id != "":
                qry += " WHERE n.id = $entity_id "
            else:
                qry += "WHERE SUBSTRING(TOLOWER(n.common_name), 0, 1 ) = $startletter "
        elif searchtarget == "plants":
            qry = "MATCH (n:Plant) "
            if entity_id != "":
                qry += " WHERE n.id = $entity_id "
            else:
                qry += "WHERE SUBSTRING(TOLOWER(n.common_name), 0, 1 ) = $startletter "
        elif searchtarget == "narratives":
            qry = "MATCH (n:Narrative) "
            if entity_id != "":
                qry += " WHERE n.id = $entity_id "
            else:
                qry += "WHERE SUBSTRING(TOLOWER(n.title), 0, 1 ) = $startletter "
        elif searchtarget == "objects":
            qry = "MATCH (n:Object) "
            if entity_id != "":
                qry += " WHERE n.id = $entity_id "
            else:
                qry += "WHERE SUBSTRING(TOLOWER(n.object_name), 0, 1 ) = $startletter "
        elif searchtarget == "countries":
            qry = "MATCH (n:Country) "
            if entity_id != "":
                qry += " WHERE n.id = $entity_id "
            else:
                qry += "WHERE SUBSTRING(TOLOWER(n.country_name), 0, 1 ) = $startletter "
        elif searchtarget == "languages":
            qry = "MATCH (n:Language) "
            if entity_id != "":
                qry += " WHERE n.id = $entity_id "
            else:
                qry += "WHERE SUBSTRING(TOLOWER(n.language_name), 0, 1 ) = $startletter "
        
        
        qry += "RETURN n;"
        
        
  
        
        params = {
            "startletter" : startletter,
            "entity_id" : entity_id
        }

        #return params

        result = self.__conn.query(qry, parameters=params)

        data = []
        for record in result:
            data.append(record.data())
        
        return json.dumps(data, default = str)
    
    def get_countries(self, entity_id="", entity_label="", searchterm=""):
        if entity_id == "" and entity_label == "" and searchterm == "":
            qry = "MATCH (c:Country) RETURN c ORDER BY c.country_name"
            
            result = self.__conn.query(qry)
        elif entity_id == "" and entity_label == "" and searchterm != "":
            qry = "MATCH (c:Country) WHERE toLower(c.country_name) CONTAINS toLower($searchterm) RETURN c; "
            params = {
                "searchterm" : searchterm
            }
            result = self.__conn.query(qry, parameters = params)
        else:
            qry = "MATCH (n:"+entity_label +")-[r]-(c:Country) WHERE n.id = $id RETURN c ORDER BY c.country_name"
            params = {
                "id" : entity_id
            }
            result = self.__conn.query(qry, parameters = params)
        #print(qry)
        #print(result)
        countries = []
        if result != None:
            for record in result:
                countries.append(record.data()['c'])
        return json.dumps(countries)
    
    def get_narratives(self, entity_id="", entity_label="", searchterm=""):
        if (entity_id == "" or entity_label == "") and searchterm == "":
            qry = "MATCH (n:Narrative) RETURN n "
            result = self.__conn.query(qry)
        elif searchterm != "":
            qry = "MATCH (n:Narrative) WHERE toLower(n.title) CONTAINS toLower($searchterm) OR toLower(n.text) CONTAINS toLower($searchterm) RETURN n "
            params = {
                "searchterm" : searchterm
            }
            result = self.__conn.query(qry, parameters = params)
        else:
            qry = "MATCH (x:"+entity_label +")-[r]-(n:Narrative) WHERE x.id = $id return n"
            params = {
                "id" : entity_id
            }
            result = self.__conn.query(qry, parameters = params)
        
        #print(result)
        narratives = []
        if result != None:
            for record in result:
                narratives.append(record.data()['n'])
        return json.dumps(narratives)
    

    def get_animal_taxonomy_node(self, animal_id):
        qry = "MATCH (a:Animal) WHERE a.id = $animal_id "
        qry += "OPTIONAL MATCH (a)-[r1:BELONGS_TO]->(g:Genus)-[r2:BELONGS_TO]->(f:Family)-[r3]->(o:Order)-[r4:BELONGS_TO]->(c:Class)-[r5:BELONGS_TO]->(p:Phylum)-[r6:BELONGS_TO]->(k:Kingdom) "
        qry += "RETURN a, g, f, o, c, p, k;"
        params = {
            "animal_id" : animal_id
        }
        animals = []
        result = self.__conn.query(qry, parameters = params)
        if result != None:
            for record in result:
                animals.append(record.data())
        return animals
    
    def get_plant_taxonomy_node(self, plant_id):
        qry = "MATCH (pl:Plant) WHERE pl.id = $plant_id "
        qry += "OPTIONAL MATCH (pl)-[r1:BELONGS_TO]->(g:Genus)-[r2:BELONGS_TO]->(f:Family)-[r3]->(o:Order)-[r4:BELONGS_TO]->(c:Class)-[r5:BELONGS_TO]->(p:Phylum)-[r6:BELONGS_TO]->(k:Kingdom) "
        qry += "RETURN pl, g, f, o, c, p, k;"
        params = {
            "plant_id" : plant_id
        }
        plants = []
        result = self.__conn.query(qry, parameters = params)
        if result != None:
            for record in result:
                plants.append(record.data())
        return plants

    def get_animals(self, animal_name = "", entity_id="", entity_label=""):
        if entity_id == "" and animal_name == "":
            qry = "MATCH (a:Animal) RETURN a; "
            result = self.__conn.query(qry)
        elif entity_id != "":
            qry = "MATCH (n:"+entity_label+")-[r]-(a:Animal) WHERE n.id = $id return  a;"
            params = {
                "id" : entity_id
            }
            result = self.__conn.query(qry, parameters = params)
        elif animal_name != "":
            qry = "MATCH (a:Animal) WHERE tolower(a.common_name) CONTAINS tolower($animal_name) OR tolower(a.scientific_name) CONTAINS toLower($animal_name) OR tolower(a.species) CONTAINS toLower($animal_name) RETURN  a;"
            params = {
                "animal_name" : animal_name
            }
            result = self.__conn.query(qry, parameters = params)
        else:
            qry = "MATCH (a:Animal) RETURN  a;"
            result = self.__conn.query(qry)
        
        #print(result)
        animals = []
        if result != None:
            for record in result:
                animals.append(record.data()['a'])
        return json.dumps(animals)
    


    def get_plants(self, plant_name = "", entity_id="", entity_label=""):
        if entity_id == "" and plant_name == "":
            qry = "MATCH (p:Plant) RETURN p "
            result = self.__conn.query(qry)
        elif entity_id != "" and entity_label != "":
            qry = "MATCH (n:" + entity_label + ")-[r]-(p:Plant) WHERE n.id = $id return p"
            params = {
                "id" : entity_id
            }
            result = self.__conn.query(qry, parameters = params)
        elif plant_name != "":
            qry = "MATCH (p:Plant) WHERE tolower(p.common_name) CONTAINS $plant_name OR tolower(p.scientific_name) CONTAINS $plant_name OR tolower(p.plant_name) CONTAINS $plant_name RETURN p;"
            params = {
                "plant_name" : plant_name
            }
            result = self.__conn.query(qry, parameters = params)
        else:
            qry = "MATCH (p:Plant) RETURN p;"
            result = self.__conn.query(qry)
        
        #print(result)
        plants = []
        if result != None:
            for record in result:
                plants.append(record.data()['p'])
        return json.dumps(plants)
    

    def get_languages(self):
        qry = "MATCH (l:Language) RETURN l ORDER BY l.language_name; "
        result = self.__conn.query(qry)
        languages = []
        if result != None:
            for record in result:
                languages.append(record.data()['l'])
        return json.dumps(languages)
    
    def get_objects(self, searchterm = "", entity_id = "", entity_label = ""):
        
        if searchterm != "":
            qry = "MATCH (o:Object) WHERE toLower(o.object_name) CONTAINS toLower($object_name) "
            qry += "RETURN o ORDER BY o.object_name; "
            params = {
                "object_name" : searchterm
            }
        elif searchterm == "" and entity_id != "" and entity_label == "":
            qry = "MATCH (o:Object) WHERE o.id = $entity_id RETURN o; "
            params = {
                "entity_id" : entity_id
            }
        elif searchterm == "" and entity_id != "" and entity_label != "":
            qry = "MATCH (o:Object)-[r]-(x:" + entity_label + ") WHERE x.id = $entity_id RETURN o; "
            params = {
                "entity_id" : entity_id
            }
        else:
            qry = "MATCH (o:Object) RETURN o; "
            params = {}
        
        result = self.__conn.query(qry, parameters=params)
        objects = []
        if result != None:
            for record in result:
                objects.append(record.data()['o'])
        return json.dumps(objects)
    
    def get_concepts(self, searchterm = "", entity_id = "", entity_label = ""):
        
        if searchterm != "":
            qry = "MATCH (c:Concept) WHERE toLower(c.concept_name) CONTAINS toLower($object_name) "
            qry += "RETURN c ORDER BY c.concept_name; "
            params = {
                "object_name" : searchterm
            }
        elif searchterm == "" and entity_id != "" and entity_label == "":
            qry = "MATCH (c:Concept) WHERE c.id = $entity_id RETURN c; "
            params = {
                "entity_id" : entity_id
            }
        elif searchterm == "" and entity_id != "" and entity_label != "":
            qry = "MATCH (c:Concept)-[r]-(x:" + entity_label + ") WHERE x.id = $entity_id RETURN c; "
            params = {
                "entity_id" : entity_id
            }
        else:
            qry = "MATCH (c:Concept) RETURN c; "
            params = {}
        
        result = self.__conn.query(qry, parameters=params)
        objects = []
        if result != None:
            for record in result:
                objects.append(record.data()['c'])
        return json.dumps(objects)

    def search_bio_data(self, searchterm):
        url = 'https://api.gbif.org/v1/species/match?name=' + searchterm
        response = requests.get(url)
        data = json.loads(response.content)
        if 'species' in data.keys():
            return data
        else:
            return {}
    